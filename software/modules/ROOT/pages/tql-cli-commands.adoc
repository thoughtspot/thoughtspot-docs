= TQL reference
:last_updated: 02/20/2021
:linkattrs:
:experimental:

TQL is the ThoughtSpot language for entering SQL commands.
This reference lists TQL commands you can use to create a schema, verify a data load, and more.

You can use TQL either xref:schema-upload.adoc[through the ThoughtSpot application's web interface] or the xref:tql-cli-commands.adoc[command line interface] in the Linux shell.

Use  `--query_results_apply_top_row_count <number>` flag to limit the number of result rows that a query returns.

For example:

[source,bash]
----
$ tql --query_results_apply_top_row_count 100`
----

As a best practice, recommend that you enclose object names (database, schema, table, and column) in double quotes, and use single quotes for column values.

When referring to objects using fully qualified object names, use the following syntax:

[source]
----
"database"."schema"."table"
----

To get help with SQL when using TQL,  enter `help` on the command line.

You can use TQL to view and modify schemas and data in tables. Remember to add a semicolon after each command.

TIP: Commands are not case-sensitive; we capitalized them here here for readability.

CAUTION: Worksheets and pinboards in ThoughtSpot depend on the data in the underlying tables. Be careful when modifying tables directly. If you change or remove a schema on which objects rely, the objects may become invalid.

== View schemas and data

The following commands enable you view schemas and data:

* <<show-databases,SHOW DATABASES>>
* <<use-database,USE <database&#62;>>
* <<show-schemas,SHOW SCHEMAS>>
* <<show-tables,SHOW TABLES>>
* <<show-table,SHOW TABLE <table&#62;>>
* <<script-server,SCRIPT SERVER>>
* <<script-database,SCRIPT DATABASE <database>>>
* <<script-table,SCRIPT TABLE <table&#62;>>
* <<select-from-where-group-order,SELECT <cols_or_expr> FROM <table_list>,WHERE <predicates>&#93; &#91;GROUP BY <expr>&#93; &#91;ORDER BY <expr>&#93;>>

[#show-databases]
include::partial$sql/show-databases.adoc[]

[#use-database]
include::partial$sql/use-database.adoc[]

[#show-schemas]
include::partial$sql/show-schemas.adoc[]

[#show-tables]
include::partial$sql/show-tables.adoc[]

[#show-table]
include::partial$sql/show-table.adoc[]

[#script-server]
include::partial$sql/script-server.adoc[]

[#script-database]
include::partial$sql/script-database.adoc[]

[#script-table]
include::partial$sql/script-table.adoc[]

[#select-from-where-group-order]
include::partial$sql/select-from-where-group-order.adoc[]

== Schema creation

The following commands enable you to create schemas:

* <<create-database,CREATE DATABASE <database&gt;>>
* <<create-schema,CREATE SCHEMA <schema&gt;>>
* <<create-table,CREATE TABLE <table> (<column_definitions> &#91;<constraints>&#93;) &#91;PARTITION BY HASH (<number>) &#91;KEY ("<column>")&#93;&#93;)]>>

[#create-database]
include::partial$sql/create-database.adoc[]

[#create-schema]
include::partial$sql/create-schema.adoc[]

[#create-table]
include::partial$sql/create-table.adoc[]

== Schema modification

The following commands enable you to modify schemas:

* <<drop-database,DROP DATABASE <database&#62;>>
* <<drop-schema,DROP SCHEMA <schema&#62;>>
* <<drop-table,DROP TABLE <table&#62;>>
* <<truncate-table,TRUNCATE TABLE <table&#62;>>
* <<alter-table,ALTER TABLE <table> ADD|DROP|RENAME COLUMN <column&#62;>>
* <<drop-pk,ALTER TABLE <table> DROP CONSTRAINT PRIMARY KEY>>
* <<drop-fk,ALTER TABLE <table> DROP [CONSTRAINT | RELATIONSHIP&#93; <name&#62;>>
* <<change-partitions,ALTER TABLE <table> &#91;SET DIMENSION | SET FACT &#91;PARTITION BY  HASH &#91;(<shards>)&#93; &#91;KEY(<column>)&#93;&#93;&#93;>>
* <<change-data-type,ALTER TABLE <table> MODIFY COLUMN <column> <new_data_type>]>>

[#drop-database]
include::partial$sql/drop-database.adoc[]

[#drop-schema]
include::partial$sql/drop-schema.adoc[]

[#drop-table]
include::partial$sql/drop-table.adoc[]

[#truncate-table]
include::partial$sql/truncate-table.adoc[]

[#alter-table]
include::partial$sql/alter-table.adoc[]

[#drop-pk]
include::partial$sql/drop-pk.adoc[]

[#drop-fk]
include::partial$sql/drop-fk.adoc[]

[#change-partitions]
include::partial$sql/change-partitions.adoc[]

[#change-data-type]
include::partial$sql/change-data-type.adoc[]

== Modify data

The following commands enable you to modify data:

* <<insert-values,INSERT INTO <table> VALUES \...>>
* <<select-into,SELECT <cols_or_expr> INTO <table_list> FROM <table_list> [WHERE <predicates>] [GROUP BY <expr>] [ORDER BY <expr>]>>
* <<set-load-priority,
ALTER TABLE <table> SET LOAD PRIORITY <value> <new_data_type&#62;>>
* <<update-rows,UPDATE <table> \... SET \... [WHERE \...&#93;>>
* <<delete-from-table,DELETE FROM <table> [WHERE\...&#93;>>

[#insert-values]
include::partial$sql/insert-values.adoc[]

[#select-into]
include::partial$sql/select-into.adoc[]

[#set-load-priority]
include::partial$sql/set-load-priority.adoc[]

[#update-rows]
include::partial$sql/update-rows.adoc[]

[#delete-from-table]
include::partial$sql/delete-from-table.adoc[]

== Constraints and relationships

ThoughtSpot uses constraints and relationships to define the relationships between tables, and specify how they can be joined. However, it does not enforce the constraints, because they are in a transactional database.

You can define the following constraints when creating a table with `CREATE TABLE`, or add them to an existing table using the `ADD CONSTRAINT` syntax:

* <<pk,PRIMARY KEY>>
* <<fk,FOREIGN KEY>>
* <<relationship,RELATIONSHIP>>

[#pk]
include::partial$sql/pk.adoc[]

[#fk]
include::partial$sql/fk.adoc[]

[#relationship]
include::partial$sql/relationship.adoc[]

== Permitted joins and necessary permissions

include::partial$joins-matrix.adoc[]

== Data types

ThoughtSpot supports a simplified list of data types:

* <<character,Character>>
* <<floating-point,Floating point>>
* <<boolean,Boolean>>
* <<integer,Integer>>
* <<date-time,Date or time>>

[#character]
Character:: `VARCHAR(_n_)`
+
Specify the maximum number of characters, as in `VARCHAR(255)`. The size limit is 64MB for `VARCHAR` values.

[#floating-point]
Floating point::
+
* `DOUBLE` ThoughtSpot recommends that you use `DOUBLE`.
* `FLOAT`

[#boolean]
Boolean:: `BOOL`
+
Can be `true` or `false`.

[#integer]
Integer::
+
* `INT` holds 32 bits
* `BIGINT` holds 64 bits

[#date-time]
Date or time::
+
* `DATE`
* `DATETIME` is stored at the granularity of seconds.
* `TIMESTAMP` is stored at the granularity of seconds. Identical to `DATETIME`, here for syntax compatibility.
* `TIME` is stored at the granularity of seconds.
* ThoughtSpot stores date and timestamp values in epoch format.
